# Conceitos básicos de programação


Ensinamos R porque facilita muito a análise de dados, o tema principal deste livro. Ao codificar em R, podemos executar com eficiência análise exploratória de dados, criar canais de análise de dados e preparar a visualização de dados para comunicar resultados. No entanto, R não é apenas um ambiente de análise de dados, mas uma linguagem de programação. Programadores avançados de R podem desenvolver pacotes complexos e até melhorar o R, embora não abordemos a programação avançada neste livro. No entanto, nesta seção, apresentamos três conceitos-chave de programação: expressões condicionais, for-loops e funções. Estes não são apenas os principais componentes da programação avançada, mas às vezes são úteis durante a análise de dados. Também observamos que existem várias funções amplamente usadas para programação em R, mas que não discutiremos neste livro. Esses incluem `split`, `cut`, `do.call` e `Reduce`, bem como o pacote __data.table__. Vale a pena aprender como usá-los, se você quiser se tornar programador especialista em R.

## Expressões condicionais {#conditionals}

Expressões condicionais são uma das características básicas da programação. Eles são usados para o que é chamado de _flow control_. A expressão condicional mais comum é a instrução _if-else_. Em R, podemos fazer muitas análises de dados sem condicionais. No entanto, eles aparecem ocasionalmente e você precisará deles assim que começar a escrever suas próprias funções e pacotes.

Aqui está um exemplo muito simples que mostra a estrutura geral de uma instrução _if-else_. A idéia básica é imprimir o recíproco de `a` a menos que `a` deixe 0:

```{r}
a <- 0

if(a!=0){
print(1/a)
} else{
print("No reciprocal for 0.")
}
```


Vejamos outro exemplo usando o conjunto de dados de assassinatos nos EUA. EUA:

```{r}
library(dslabs)
data(murders)
murder_rate <- murders$total/ murders$population*100000
```


Aqui está um exemplo muito simples que nos diz quais estados, se houver, têm uma taxa de homicídios inferior a 0,5 por 100.000. As declarações `if` eles nos protegem do caso em que nenhum estado satisfaz a condição.

```{r}
ind <- which.min(murder_rate)

if(murder_rate[ind] < 0.5){
print(murders$state[ind])
} else{
print("No state has murder rate that low")
}
```

Se tentarmos novamente com uma taxa de 0,25, obteremos uma resposta diferente:

```{r}
if(murder_rate[ind] < 0.25){
print(murders$state[ind])
} else{
print("No state has a murder rate that low.")
}
```


Uma função relacionada que é muito útil é `ifelse`. Essa função usa três argumentos: um lógico e duas respostas possíveis. Se o lógico for `TRUE`, retorna o valor no segundo argumento e, se for `FALSE`, retorna o valor no terceiro argumento. Aqui está um exemplo:

```{r}
a <- 0
ifelse(a > 0, 1/a, NA)
```

Essa função é particularmente útil porque é útil para vetores. Isso examina cada entrada do vetor lógico e retorna elementos do vetor fornecido no segundo argumento, se a entrada for `TRUE`, ou elementos do vetor fornecido no terceiro argumento, se a entrada for `FALSE`.

```{r}
a <- c(0, 1, 2, -4, 5)
result <- ifelse(a > 0, 1/a, NA)
```

Esta tabela nos ajuda a ver o que aconteceu:
```{r, echo=FALSE}
tmp <- data.frame(a = a, is_a_positive = a > 0, answer1 = 1/a, answer2 = NA, result = result)
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Aqui está um exemplo de como essa função pode ser facilmente usada para substituir todos os valores ausentes em um vetor por zeros:

```{r}
data(na_example)
no_nas <- ifelse(is.na(na_example), 0, na_example)
sum(is.na(no_nas))
```

Duas outras funções úteis são `any` e `all`. A função `any` pega um vetor de lógicas e retorna `TRUE` se alguma das entradas for `TRUE`. A função `all` pega um vetor de lógicas e retorna `TRUE` se todas as entradas forem `TRUE`. Aqui está um exemplo:

```{r}
z <- c(TRUE, TRUE, FALSE)
any(z)
all(z)
```

## Como definir funções

À medida que ganham mais experiência, eles precisam executar as mesmas operações repetidamente. Um exemplo simples é o cálculo de médias. Podemos calcular a média de um vetor `x` usando funções `sum` e `length`: `sum(x)/length(x)`. Como fazemos isso repetidamente, é muito mais eficiente escrever uma função que execute essa operação. Essa operação específica é tão comum que alguém já escreveu a função `mean` e está incluído na base R. No entanto, você encontrará situações em que a função ainda não existe, portanto, R permite que você escreva uma. Você pode definir uma versão simples de uma função que calcula a média da seguinte maneira:

```{r}
avg <- function(x){
s <- sum(x)
n <- length(x)
s/n
}
```

Agora `avg` é uma função que calcula a média:

```{r}
x <- 1:100
identical(mean(x), avg(x))
```

Observe que as variáveis definidas em uma função não são salvas no espaço de trabalho. Então, enquanto usamos `s` e `n` quando chamamos (_call_ em inglês) `avg`, os valores são criados e alterados apenas durante a chamada. Aqui podemos ver um exemplo ilustrativo:

```{r}
s <- 3
avg(1:10)
s
```

Note como `s` ainda é `r s` depois que ligamos `avg`.


Em geral, funções são objetos, portanto, atribuímos nomes de variáveis a eles com `<-`. A função `function` diz a R que ele está prestes a definir uma função. A forma geral da definição de uma função é assim:

```{r, eval=FALSE}
my_function <- function(VARIABLE_NAME){
perform operations on VARIABLE_NAME and calculate VALUE
VALUE
}
```

As funções que eles definem podem ter vários argumentos, bem como valores padrão. Por exemplo, podemos definir uma função que calcula a média aritmética ou geométrica, dependendo de uma variável definida pelo usuário como esta:

```{r}
avg <- function(x, arithmetic = TRUE){
n <- length(x)
ifelse(arithmetic, sum(x)/n, prod(x)^(1/n))
}
```

Aprenderemos mais sobre como criar funções através da experiência à medida que enfrentamos tarefas mais complexas.

## _Namespaces_

Quando eles começarem a se tornar usuários experientes do R, provavelmente precisarão carregar vários plug-ins de pacotes (_add-ons_) para algumas de suas varreduras. Assim que fazem isso, é provável que descubram que dois pacotes usam o mesmo nome para duas funções diferentes. E muitas vezes essas funções fazem coisas completamente diferentes. De fato, já vimos isso porque os pacotes base R __dplyr__e__stats__ definem uma função `filter`. Existem outros cinco exemplos em __dplyr__. Sabemos disso porque, quando carregamos __dplyr__ pela primeira vez, vemos a seguinte mensagem:

```
The following objects are masked from ‘package:stats’:

filter, lag

The following objects are masked from ‘package:base’:

intersect, setdiff, setequal, union
```

Então, o que R faz quando escrevemos `filter`? Você usa a função __dplyr__ou a função__stats__? Do nosso trabalho anterior, sabemos que ele usa __dplyr__. Mas e se quisermos usar __stats__?

Essas funções vivem em diferentes _namespaces_. R seguirá uma determinada ordem ao procurar uma função nesses _namespaces_. Você pode ver o pedido escrevendo:

```{r, eval=FALSE}
search()
```

A primeira entrada nesta lista é o ambiente global que inclui todos os objetos que eles definem.

E daí se quisermos usar o `filter` __stats__ em vez de `filter` __dplyr__mas__dplyr__ aparece primeiro na lista de pesquisa? Eles podem forçar o uso de um _namespace_ específico usando dois pontos duplos ( `::`) assim:

```{r, eval=FALSE}
stats::filter
```

Se queremos ter certeza absoluta de que usamos o `filter` __dplyr__, podemos usar:

```{r, eval=FALSE}
dplyr::filter
```

Lembre-se de que, se queremos usar uma função em um pacote sem carregar o pacote inteiro, também podemos usar dois pontos duplos.

Para obter mais informações sobre esse tópico mais avançado, recomendamos o livro de pacotes R^[http://r-pkgs.had.co.nz/namespace.html].

## Loops para

A fórmula para a soma da série $1+2+\dots+n$ é $n(n+1)/2$. E se não tivéssemos certeza de que essa era a função correta? Como poderíamos verificar? Usando o que aprendemos sobre funções, podemos criar um que calcule $S_n$:

```{r}
compute_s_n <- function(n){
x <- 1:n
sum(x)
}
```

Como podemos calcular $S_n$ para vários valores de $n$, digamos $n=1,\dots,25$? Escrevemos 25 linhas de chamada de código `compute_s_n`? Não. É para isso que servem os loops de programação. Nesse caso, estamos realizando a mesma tarefa repetidamente, e a única coisa que está mudando é o valor de $n$. Os loops for permitem definir o intervalo que nossa variável leva (no nosso exemplo $n=1,\dots,10$), altere o valor e avalie a expressão enquanto você faz o loop _.

Talvez o exemplo mais simples de um loop for seja esse código inútil:
```{r}
for(i in 1:5){
print(i)
}
```

Aqui está o loop for que escreveríamos para o nosso exemplo $S_n$:

```{r}
m <- 25
s_n <- vector(length = m) # create an empty vector
for(n in 1:m){
s_n[n] <- compute_s_n(n)
}
```
Em cada iteração $n=1$, $n=2$, etc ..., calculamos $S_n$ e mantemos na entrada $n$ do `s_n`.

Agora podemos criar um gráfico para procurar um padrão:

```{r eval=FALSE}
n <- 1:m
plot(n, s_n)
```

```{r sum-of-consecutive-squares, out.width="50%", echo=FALSE}
rafalib::mypar()
n <- 1:m
plot(n, s_n)
```


Se você percebeu que parece quadrático, está no caminho certo porque a fórmula é $n(n+1)/2$.
<!--
que podemos confirmar com uma tabela:

```{r show_s_n_table}
head(data.frame(s_n = s_n, formula = n*(n+1)/2))
```

Também podemos sobrepor os dois resultados usando a função `lines` para desenhar uma linha sobre os pontos plotados anteriormente:

```{r s_n-v-n}
plot(n, s_n)
lines(n, n*(n+1)/2)
```

-->

## Vectorização e funcional {#vectorization}

Embora os for-loops sejam um conceito importante para entender, eles não são muito usados em R. À medida que aprendem mais R, eles descobrirão que _vectoring_ é preferível aos for-loops, pois resulta em um código mais curto e claro. . Já vimos exemplos na seção aritmética vetorial. Uma função _vectorized_ é uma função que aplicará a mesma operação a cada um dos vetores.

```{r}
x <- 1:10
sqrt(x)
y <- 1:10
x*y
```

Para fazer esse cálculo, não precisamos de loops de for. No entanto, nem todas as funções funcionam dessa maneira. Por exemplo, a função que acabamos de escrever, `compute_s_n`, ele não funciona elemento a elemento, pois espera um escalar. Esse trecho de código não executa a função em todas as entradas de `n`:

```{r, eval=FALSE}
n <- 1:25
compute_s_n(n)
```

As _functionals_ são funções que nos ajudam a aplicar a mesma função a cada entrada em um vetor, matriz, _data frame_ ou lista. Aqui abordamos o funcional que opera em vetores numéricos, lógicos e de caracteres: `sapply`.

A função `sapply` nos permite executar operações baseadas em elementos (_element-wise_ em inglês) em qualquer função. Aqui podemos ver como funciona:

```{r}
x <- 1:10
sapply(x, sqrt)
```

Cada elemento de `x` é passado para a função `sqrt` e retorna o resultado. Esses resultados são concatenados. Nesse caso, o resultado é um vetor do mesmo comprimento que o original, `x`. Isso implica que o loop for acima pode ser escrito da seguinte maneira:

```{r s_n-v-n-sapply, eval=FALSE}
n <- 1:25
s_n <- sapply(n, compute_s_n)
```

Outros funcionais são `apply`, `lapply`, `tapply`, `mapply`, `vapply` e `replicate`. Nós usamos principalmente `sapply`, `apply` e `replicate` neste livro, mas recomendamos que se conheçam, pois podem ser muito úteis.

## Exercícios

1\. O que essa expressão condicional retornará?

```{r, eval=FALSE}
x <- c(1,2,-3,4)

if(all(x>0)){
print("All Postives")
} else{
print("Not all positives")
}
```


2\. Qual das seguintes expressões é sempre `FALSE` quando pelo menos uma entrada de um vetor lógico `x` é verdade?

para. `all(x)`
b. `any(x)`
c. `any(!x)`
d. `all(!x)`

3\. A função `nchar` informa quantos caracteres um vetor de caracteres possui. Escreva uma linha de código que atribua o objeto `new_names` a abreviação de estado quando o nome do estado tiver mais de 8 caracteres.


4\. Crie uma função `sum_n` que, por qualquer valor, digamos $n$, calcule a soma dos números inteiros de 1 a n (inclusive). Use a função para determinar a soma dos números inteiros de 1 a 5.000.

5\. Crie uma função `altman_plot` que leva dois argumentos, `x` e `y` e faça um gráfico da diferença em relação à soma.

6\. Depois de executar o código a seguir, qual é o valor de `x`?

```{r, eval=FALSE}
x <- 3
my_func <- function(y){
x <- 5
y+5
}
```

7\. Escreva uma função `compute_s_n` isso para qualquer $n$ calcular a soma $S_n = 1^2 + 2^2 + 3^2 + \dots n^2$. Indique o valor da soma quando $n=10$.

8\. Definir um vetor de número vazio `s_n` tamanho 25 usando `s_n <- vector("numeric", 25)` e armazene os resultados de $S_1, S_2, \dots S_{25}$ usando um loop for.

9\. Repita o exercício 8, mas desta vez use `sapply`.

10\. Repita o exercício 8, mas desta vez use `map_dbl`.

Onze\. Gráfico $S_n$ versus $n$. Use pontos definidos por $n=1,\dots,25$.

12\. Confirme se a fórmula para esta soma é $S_n= n(n+1)(2n+1)/6$.
















